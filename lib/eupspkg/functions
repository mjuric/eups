#!/bin/bash -- just to enable syntax highlighting --
#
# EupsPkg Distrib Mechanism Function Library
#
# Defines utility functions, default implementations of pkgbuild verbs, and
# performs common initialization.
#
# Should be sourced early on in pkgbuild scripts.
#

set -e

##################### ---- UNIT TEST HELPERS ---- #####################

ut()
{
	# usage: ut <code_to_evaluate> <op> <expected_result>
	#
	# evals code in $1 and uses $2 to compare it to $3

	eval RES="$($1)"
	if [ "$RES" $2 "$3" ]; then
		echo "$@": ok.
	else
		echo "$@": FAILED.
	fi
}

##################### ---- UTILITY FUNCTIONS ---- #####################

#
# Verbosity levels:
#
#   >= -3: Show fatal errors (fatal)
#   >= -2: Show errors (error)
#   >= -1: Show warnings (warn)
#   >=  0: Show messages (msg)
#   >=  1: Show add'l informational messages (info)
#   >=  2: Show debugging messages (debug)
#   >=  3: Activate Bash tracing (set -x)

# The funny '|| true' construct is there to ensure this works with 'set -e'
die()   { [[ $VERBOSE -ge -3 ]] && echo "pkgbuild (fatal): $@" >&2 || true; exit -1; }
error() { [[ $VERBOSE -ge -2 ]] && echo "pkgbuild (error): $@" >&2 || true; }
warn()  { [[ $VERBOSE -ge -1 ]] && echo "pkgbuild (warning): $@" >&2 || true; }
msg()   { [[ $VERBOSE -ge 0 ]] && echo "pkgbuild: $@" >&2 || true; }
info()  { [[ $VERBOSE -ge 1 ]] && echo "pkgbuild (info): $@" >&2 || true; }
debug() { [[ $VERBOSE -ge 2 ]] && echo "pkgbuild (debug): $@" >&2 || true; }

die_if_empty() { eval VAL_="\$$1"; if [ -z "$VAL_" ]; then die "$1 is not set. refusing to proceed."; fi; }

append_pkginfo()
{
	# Append VARNAME=VARVALUE line to pkginfo file
	# Should only be used by the 'create' verb.
	#
	# usage: append_pkginfo <VARNAME> [VARVALUE]
	#
	# If VARVALUE is not given $VARNAME will be evaluated
	#

	die_if_empty PKGINFO

	if [[ $# == 1 ]]; then
		eval VAL_="\$$1";
	else
		VAL_="$2"
	fi

	echo $1="'""$VAL_""'" >> "$PKGINFO"
	
	info "appended $1='$VAL_' to pkginfo."
}

use_parallel_jobs()
{
	# Tweak MAKEFLAGS and SCONSFLAGS to run at the given level of parallelism
	#
	# usage: use_parallel_jobs <NJOBS>
	#
	NJOBS=$1

	# Note: If this function is called multiple times, last -j option will take presedence.
	# Not elegant, but works.
	export MAKEFLAGS="$SCONSFLAGS -j $NJOBS"
	export SCONSFLAGS="$SCONSFLAGS -j $NJOBS"

	info "Using $NJOBS parallel jobs."
	debug "  MAKEFLAGS=$MAKEFLAGS"
	debug "  SCONSFLAGS=$SCONSFLAGS"
}

detect_compiler()
{
	#
	# Properly detects C and C++ compiler types. Dies if the two are not
	# the same.
	#
	# Defines:
	#	COMPILER_TYPE, CXX_COMP_TYPE, C_COMP_TYPE
	#

	# Construct test source files
	local S="$(mktemp -t comptest.XXXXX)".c
	cat > "$S" <<-EOF
		#include <stdio.h>

		int main()
		{
			#if defined(__clang__)
				printf("clang");
			#elif defined(__ICC) || defined(__INTEL_COMPILER)
				printf("icc");
			#elif defined(__GNUC__) || defined(__GNUG__)
				printf("gcc");
			#elif defined(_MSC_VER)
				printf("msvc");
			#elif defined(__PGI)
				printf("pgcc");
			#else
				printf("unknown");
			#endif

			return 0;
		}
	EOF
	local SCXX="$(mktemp -t comptest.XXXXX)".cxx
	cp "$S" "$SCXX"

	# Build and run the test
	local O=$(mktemp -t comptest.XXXXX)
	local OCXX=$(mktemp -t comptest.XXXXX)
	CC1="${CC:-cc}"
	CXX1="${CXX:-c++}"
	"$CC1" "$S" -o "$O"
	"$CXX1" "$SCXX" -o "$OCXX"
	C_COMP_TYPE=$("$O")
	CXX_COMP_TYPE=$("$OCXX")

	# Check compiler type consistency
	if [[ "$CXX_COMP_TYPE" != "$C_COMP_TYPE" ]]; then
		die "C and C++ compiler versions differ ($CC1 is of type '$C_COMP_TYPE' while $CXX1 is of type '$CXX_COMP_TYPE')"
	fi

	COMPILER_TYPE="$CXX_COMP_TYPE"
}

autoversion()
{
	# Heuristics to guess PRODUCT/VERSION, assuming we were called from
	# a working directory of a git repository.
	#
	# This exists primarily to enable debugging.
	if hash git 2>/dev/null; then
		msg "using git heuristics to deduce pkginfo contents."

		FLAVOR=generic
		REMOTE=$(git config --get remote.origin.url || true)
		if [[ -z "$REMOTE" ]]; then
			die "No git remote named 'origin', or git error.";
		fi

		PRODUCT="$(basename "$REMOTE" .git)"

		# Construct an EUPS-friendly version string based on git info
		# Does not encode dependencies in version (no +N part)
		## VERSION="$(git describe --always $DIRTY_FLAG | tr - _)"
		deduce_version_using_git $DIRTY_FLAG

		msg "    auto-determined: PRODUCT=$PRODUCT"
		msg "    auto-determined: VERSION=$VERSION"
		msg "    assumed:         FLAVOR=$FLAVOR"
	else
		die "could not execute 'git' to automatically deduce PRODUCT and VERSION."
	fi
}

_lex_normalize()
{
	# Given a list of dot-separated versions, echo a two-column list
	# where the first column is equal to, eg., sprintf "%10s%10s%10s" x,
	# y, z for a tag x.y.z.  The columns are separated by '|'.  This
	# makes it possible to compare the versions by lexicographically
	# sorting on the first column.
	#
	# Returns via STDOUT

	local tag
	for tag in "$@"; do
		IFS="."
		local VC=( $tag )
		unset IFS

		local FORMAT="$(yes "%10s" 2>/dev/null | head -n ${#VC[@]} | tr -d '\n')"
		local VH=$(printf "$FORMAT" "${VC[@]}")

		echo "$VH|$tag"
	done
}

_earliest_version()
{
	# Given a list of dot-separated versions, return the earliest one.
	#
	# Returns via STDOUT

	_lex_normalize "$@" | sort -t '|' -k1,1 | head -n 1 | cut -d'|' -f 2
}

_ut_earliest_version()
{
	# Unit tests of _earliest_version()

	ut "_earliest_version 1.1 1.1.0" == "1.1"
	ut "_earliest_version 1.1.0 1.1.0" == "1.1.0"
	ut "_earliest_version 1.2.3 1.2.2" == "1.2.2"
	ut "_earliest_version 1.2.2 1.2.3" == "1.2.2"

	ut "_earliest_version 1.2 1.2.3" == "1.2"
	ut "_earliest_version 1.2.2 1.2.3 1.3" == "1.2.2"

	ut "_earliest_version 1.2 1.2a" == "1.2"
	ut "_earliest_version 1.2.1 1.2a.2" == "1.2.1"
	ut "_earliest_version 1.2a.2 1.2a.1" == "1.2a.1"
	ut "_earliest_version 1.2a.2 1.2b.1" == "1.2a.2"
}

_eups_compat_version()
{
	# Make a string "EUPS compatible" by removing illegal characters
	# (anything other than alphanumerics, dot, and underscore).
	#
	# Returns via STDOUT

	echo "$@" | tr -c -d '[0-9a-zA-z._]'
}

glob_match()
{
	# usage: glob_match <pattern>
	#
	# Match lines on STDIN against <pattern> and echo only those that
	# match.

	while read line; do
		if [[ "$line" == $1 ]]; then
			echo "$line"
		fi
	done
}

git_version()
{
	deduce_version_using_git "$@"
	echo $VERSION
}

deduce_version_using_git()
{
	# usage: deduce_version_using_git [--dirty] [ref=HEAD] [tag_pattern='[0-9]*']
	#
	# Deduces a version identifier given a git ref.
	#
	# Applies the following logic:
	#   * If ref is a tag, returns ref
	#   * Otherwise, calls git-describe
	#     * if there are no annotated tags to describe by, returns [branch_g]<sha1>[_dirty]
	#     * otherwise, returns <tag>_g<sha1>[_dirty]
	#
	# If multiple tags are elegible to describe the ref, uses the one
	# evaluating to the lowest version.
	#
	# If --dirty is given, ref must be empty
	#
	# Defines: $VERSION
	#

	# See if there's a --dirty option
	local DIRTY=
	if [[ $1 == --dirty ]]; then
		DIRTY="--dirty"
		shift
	fi

	local REF=$1

	# Check if this ref is already a tag; if yes, we're done.
	if git show-ref -q --verify refs/tags/"$REF"; then
		VERSION=$(_eups_compat_version "$REF")
		return
	fi

	# Get pattern defining eligible tags for git-describe
	local TAG_PATTERN=${2:-'[0-9]*'}

	# Ask git-describe to describe the ref in human friendly terms, and
	# split the output on '-' sign. The result will be one of:
	#  <tag>-<seq>-g<hash>[-dirty]
	#  <hash>[-dirty]
	# with -dirty present only if --dirty flag was passed to `git describe'
	#
	local RES=$(git describe $DIRTY --first-parent --always --long --abbrev=10 --match "$TAG_PATTERN" $REF)
	if [[ -z $RES ]]; then
		die "error getting version description from git."
	fi


	IFS="-"
	local RES=($RES)
	unset IFS

	if [[ ${RES[1]} == "0" ]]; then
		# Simplify it <seq> == 0
		if [[ -z ${RES[3]} ]]; then	# drop <SHA> if not dirty
			unset RES[2]
		fi
		unset RES[1]			# drop <seq>
	elif [[ ${#RES[@]} -gt 2 ]]; then
		# Succeeded at getting a description.
		# workarounds: if there are multiple tags on the commit,
		# git-describe will return a random one.  Work around this by
		# finding the tag with the lowest version number when compared in
		# per component (i.e., "naturally").

		# Find all tags for commit pointed to by the tag found by
		# git-describe, that begin with a digit.
		local TAGSHA1=$(git show-ref --tags -d "${RES[0]}" | grep '{}$' | cut -d' ' -f 1)
		local TAGS=$(git show-ref --tags -d | grep "^$TAGSHA1" | sed 's|.* refs/tags/\(.*\)^{}|\1|' | glob_match "$TAG_PATTERN")
	
		# Find the "earliest" one
		RES[0]=$(_earliest_version ${TAGS[@]})
	else
		# Failed to get a description; still try to be friendly and
		# prepend branch name if it's on 'master' or 'next'

		# Is this commit on on 'master' or 'next'?
		local BRANCH=$(git branch --contains ${RES[0]} | cut -b 3- | grep -E '^(master|next)$')

		#if [[ -z $BRANCH ]]; then
		#	# Find the branch with the shortest name that this commit belongs to
		#	BRANCH=$(git branch --contains ${RES[0]} | cut -b 3- | awk '{ print length($1) " " $0; }' | sort -n | head -n 1 | cut -d' ' -f 2 )
		#fi

		if [[ ! -z $BRANCH ]]; then
			RES=($BRANCH "${RES[@]}")
			RES[1]="g${RES[1]}"
		fi
	fi

	# Construct the (EUPS-compatible) version string
	IFS="_" VERSION="${RES[*]}"
	unset IFS
	VERSION=$(_eups_compat_version "$VERSION")
}

version_to_git_rev()
{
	# Parse a git SHA out of the version, that can be pulled with git-clone
	#
	# Assume the versions are of the form:
	#
	#    <tag>:<n>:<sha1>:[dirty][+...]
	#
	# If the version can't be parsed, return it as-is (it may be a tag).
	#
	# Defines: GITREV
	#

	#VERSION="6.2.0.0:10:g4707c82"
	#VERSION="4707c82:dirty"

	local VER=$(echo "$VERSION" | cut -d+ -f 1)
	local SHA=$(echo "$VER" | cut -d: -f 3)
	local NF=$(echo "$VER" | grep -o : | wc -l)

	if [[ $NF -ne 2 || "${SHA:0:1}" != "g" || "$VER" = *:dirty ]]; then
		GITREV="$(echo "$VER" | tr _ -)"
	else
		GITREV=${SHA:1}
	fi
	#echo GITREV=$GITREV VER=$VER NF=$NF
	#exit -1
}

eups_declare()
{
	# Make the package known to EUPS
	#
	# NOTE: This function is not a part of the "official" API; it's here just
	# to ease debugging.

	die_if_empty PRODUCT
	die_if_empty VERSION

	# Sanity checks
	if [[ ! -d "$PREFIX/ups" ]]; then
		die "directory $PREFIX doesn't exist or is not a directory. did you forget to run 'pkgbuild install'?"
	fi

	eups declare -c "$PRODUCT" "$VERSION" -r "$PREFIX"
	msg declared "$PRODUCT-$VERSION" in "$PREFIX"
}

install_ups()
{
	# Copy the contents of ups/ to $PREFIX/ups and expand the table files
	#
	# It's necessary to call this if the native install method doesn't
	# copy/expand ups/ content

	[ ! -d ups ] && die "no 'ups' directory to copy to destination (are you running from package root?)";

	mkdir -p "$PREFIX/ups"
	cp -f -a ./ups/* "$PREFIX/ups"

	# Expand the table file, if any
	if [[ -f "$PREFIX/ups/$PRODUCT.table" ]]; then
		eups expandtable -i -W '^(?!LOCAL:)' "$PREFIX/ups/$PRODUCT.table"
		info "expanded table file '$PREFIX/ups/$PRODUCT.table'"
	else
		msg "no table file to expand (looked for '$PREFIX/ups/$PRODUCT.table')".
	fi
}

clean_old_install()
{
	#
	# Remove any existing content in $PREFIX, being extra careful
	# that $PREFIX is sane.
	#
	if [[ -e "$PREFIX" ]]; then
		P0=$(cd "$(eups path 0)/$(eups flavor)" && pwd)
		P1=$(cd "$PREFIX" && pwd)

		# Delete only if $PREFIX is a proper subdirectory of eups
		# install root
		if [[ "$P0" != "$P1" && "$P1" == "$P0"* ]]; then
			msg "deleting existing install in '$P1'"
			rm -rf "$P1"
		else
			msg "odd install directory '$PREFIX' (not a proper subdir of eups install root). not deleting it out of abundance of caution."
		fi
	fi
}

resolve_repository()
{
	#
	# Resolve the path to git repository, by expanding patterns
	# specified on RESOLVE_PATH.  If $REPOSITORY has already been
	# explicitly set, do nothing.
	#
	# RESOLVE_PATH must be of the form:
	#
	#   'git://server1/dirs1/$PRODUCT.git|http://server2/dirs2/$PRODUCT.git'
	#
	# etc., i.e., a |-delimited string of Bash strings which will be eval-ed
	# in the current environment.
	#
	# Defines: REPOSITORY
	#

	if [[ ! -z "$REPOSITORY" ]]; then
		info explicit repository given as $REPOSITORY, nothing to resolve.
		return
	fi
	
	die_if_empty REPOSITORY_PATH

	IFS='|' read -ra REPOSITORY_PATH_ARRAY <<< "$REPOSITORY_PATH"
	for PAT in "${REPOSITORY_PATH_ARRAY[@]}"; do
		eval "REPOSITORY=\"$PAT\""
		info "trying $REPOSITORY"
		if git ls-remote "$REPOSITORY" master >/dev/null 2>&1; then
			info "repository resolved to $REPOSITORY."
			return
		fi
	done

	die "failed to resolve repository for $PRODUCT-$VERSION using REPOSITORY_PATH=$REPOSITORY_PATH. Check the path or accessibility of your git repositories."
}

##################### ---- DEFAULT VERB IMPL ---- #####################

default_create()
{
	# Called to publish the package to the distribution server
	# Should generate all the files that are needed for cloning
	# --
	# CWD: Called from $pkgroot
	# Env: Nothing guaranteed to be setup-ed
	#

	# safety: refuse to work in a directory containing anything other than 'ups'
	# subdirectory. This will prevent chaos when careless users run pkgbuild create
	# in their source directories.
	if [[ ! -z "$(ls -A)" ]]; then
		die "safety first: refusing to run from a non-empty directory."
	fi

	# Make sure the important ones are here
	die_if_empty PRODUCT
	die_if_empty VERSION
	die_if_empty FLAVOR
	die_if_empty SOURCE

	# Define temporary location for pkginfo file. We'll copy
	# it to ups/pkginfo in the end, to avoid it being overwritten
	# by package creation commands below.
	PKGINFO=$(mktemp -t pkginfo.XXXXX)

	# Store the variables we know of to pkginfo
	append_pkginfo PRODUCT
	append_pkginfo VERSION
	append_pkginfo FLAVOR
	append_pkginfo SOURCE

	# Prepare the package
	resolve_repository
	append_pkginfo REPOSITORY

	version_to_git_rev

	case "$SOURCE" in
		git)
			# Use git clone to extract ups/pkgbuild. Store the SHA1 into $PKGINFO
			# Note: this is terribly inefficient, but git doesn't provide a
			# mechanism to just fetch a single file given a ref.

			git clone -q "$REPOSITORY" tmp
			(cd tmp && git checkout -q $GITREV)

			SHA1=$(cd tmp && git rev-parse HEAD)
			append_pkginfo SHA1

			mkdir ups
			if [[ -e tmp/ups/pkgbuild ]]; then
				mv tmp/ups/pkgbuild ups
			fi

			rm -rf tmp
			;;
		git-archive)
			# Extract ups/pkgbuild using git-archive
			git archive --format=tar.gz --remote="$REPOSITORY" "$VERSION" ups/pkgbuild 2>/dev/null | (tar xzf - 2>/dev/null || true)
			# note: the odd tar construct (and PIPESTATUS check) is to account for BSD/gnu tar differences:
			#       BSD tar returns success on broken pipe, gnu tar returns an error.
			if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
				# The failure may have occurred because ups/ does not exist on the remote, or because
				# of a problem with accessing the repository. The former is legal, the latter is not.
				# Find out which one is it and act accordinly.
				git archive --format=tar.gz --remote="$REPOSITORY" "$VERSION" | head -c 1 > /dev/null
				if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
					die "could not access '$REPOSITORY' via git-archive. has it been tagged with '$VERSION'"?
				fi
			fi
			mkdir -p ups
			;;
		"local")
			# Extract the full source using git-archive, falling back to git-clone in case of failure.
			git archive --format=tar.gz --remote="$REPOSITORY" "$VERSION" 2>/dev/null | (tar xzf - 2>/dev/null || true)
			# note: the odd tar construct (and PIPESTATUS check) is to account for BSD/gnu tar differences:
			#       BSD tar returns success on broken pipe, gnu tar returns an error.
			if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
				git clone -q "$REPOSITORY" .
				git checkout -q $GITREV

				SHA1=$(git rev-parse HEAD)
				append_pkginfo SHA1

				rm -rf .git
			fi
			;;
		*)
			echo "pkgbuild error: unknown source download mechanism SOURCE='$SOURCE' (known mechanisms: git, git-archive, local)."; exit -1;
	esac

	# move pkginfo file to its final location
	mkdir -p ups
	mv "$PKGINFO" ups/pkginfo
	chmod +r ups/pkginfo

	PKGINFO="ups/pkginfo"

	msg "package contents created for '$PRODUCT-$VERSION', with sources in '$SOURCE'."
}

default_fetch()
{
	# Should obtain the source and unpack it so it's the same
	# as when it was checked out from git. The source should be unpacked to
	# $pkgroot/build
	# --
	# Called by 'eups distrib install <pkgname> <version>'
	# --
	# CWD: Called from $pkgroot
	# Env: Called in environment with setup-ed dependencies, but not the package itself
	#

	die_if_empty PRODUCT
	die_if_empty VERSION

	version_to_git_rev

	case "$SOURCE" in
		git)
			# Obtain the source from a git repository
			die_if_empty REPOSITORY
			die_if_empty SHA1

			info "fetching by git cloning from $REPOSITORY"
			git clone -q "$REPOSITORY" tmp
			(cd tmp && git checkout -q $SHA1)

			rm -rf tmp/.git

			# move everything but the contents of the ups directory (as it already exists)
			find tmp -maxdepth 1 -mindepth 1 ! -name ups -exec mv {} . \;
			# move the contents of the ups directory, excluding pkgbuild and pkginfo
			find tmp/ups -maxdepth 1 -mindepth 1 ! \(  -name pkgbuild -o -name pkginfo \) -exec mv {} ups \;
			rm -f tmp/ups/pkgbuild tmp/ups/pkginfo
			rmdir tmp/ups 2>/dev/null || true

			# the tmp directory must be empty at this point
			rmdir tmp
			;;
		git-archive)
			die_if_empty REPOSITORY
			die_if_empty VERSION
			# note: the odd tar construct (and PIPESTATUS check) is to account for BSD/gnu tar differences:
			#       BSD tar returns success on broken pipe, gnu tar returns an error.

			info "fetching via git-archive from $REPOSITORY"
			git archive --format=tar.gz  --remote="$REPOSITORY" "$VERSION" | (tar xzf - --exclude ups/pkgbuild --exclude ups/pkginfo 2>/dev/null || true)
			if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
				die could not access "$REPOSITORY" via git-archive. has it been tagged with "$VERSION"?
			fi
			;;
		"local")
			;;
		*)
			die "unknown source '$SOURCE'. Malformed archive?";
			;;
	esac
}

default_prep()
{
	# Should apply any patches and prepare the code to be configured
	# --
	# Called by 'eups distrib install <pkgname> <version>'
	# Caller: buildbot, to prep the package for configuration
	# --
	# CWD: Called from $builddir
	# Env: Called in environment with setup-ed dependencies, but not the package itself
	# --
	# Typical override:
	#   apply applicable patches from $sourcedir/patches, depending
        #   on platform we're being compiled on.

	:
}

default_config()
{
	# Should apply any patches and configure the code to be built using build()
	# --
	# Called by 'eups distrib install <pkgname> <version>'
	# Caller: buildbot, to prep the package for building
	# --
	# CWD: Called from $builddir
	# Env: Called in environment with setup-ed dependencies, but not the package itself
	# --
	# Typical override:
	#   run custom configuration scripts

	if [[ -f configure ]]; then
		./configure $CONFIGURE_OPTIONS
	fi
}

default_build()
{
	# Called to build the package.
	# --
	# Caller: 'eups distrib install <pkgname> <version>'
	# Caller: buildbot, to build the package
	# --
	# CWD: Called from $builddir
	# Env: Called in environment with setup-ed dependencies, including self

	die_if_empty PRODUCT
	die_if_empty VERSION

	#
	# Attempt to autodetect the build system
	#
	if [[ -f SConstruct ]]; then
		scons opt=3 prefix="$PREFIX" version="$VERSION"
	elif [[ -f configure ]]; then
		make prefix="$PREFIX" version="$VERSION" $MAKE_BUILD_TARGETS
	elif [[ -f Makefile || -f makefile || -f GNUmakefile ]]; then
		make prefix="$PREFIX" version="$VERSION" $MAKE_BUILD_TARGETS
	elif [[ -f setup.py ]]; then
		python setup.py build
	else
		msg "no build system detected; assuming no build needed."
	fi
}

default_install()
{
	# Called to install the package, and declare it to EUPS
	# --
	# Caller: 'eups distrib install <pkgname> <version>'
	# Caller: buildbot, to build the package
	# --
	# CWD: Called from $builddir
	# Env: Called in environment with setup-ed dependencies, including self

	die_if_empty PRODUCT
	die_if_empty VERSION

	clean_old_install

	#
	# Attempt to autodetect the build system
	#
	if [[ -f SConstruct ]]; then
		scons opt=3 prefix="$PREFIX" version="$VERSION" install
	elif [[ -f Makefile || -f makefile || -f GNUmakefile ]]; then
		make prefix="$PREFIX" version="$VERSION"  $MAKE_INSTALL_TARGETS
		install_ups
	elif [[ -f setup.py ]]; then
		PYDEST="$PREFIX/lib/python"
		mkdir -p "$PYDEST"
		PYTHONPATH="$PYDEST:$PYTHONPATH" python setup.py install $PYSETUP_INSTALL_OPTIONS
		evil_setuptools_pth_fix "$PYDEST"
		install_ups
	else
		# just copy everything
		mkdir -p "$PREFIX"
		cp -a ./ "$PREFIX"
		msg "Copied the product into '$PREFIX'"
	fi
}

evil_setuptools_pth_fix()
{
	# setuptools does the *IDIOTIC* sys.path manipulation in .pth files,
	# to prepend its own path to sys.path thus making it impossible to
	# override.  The fact this lunacy managed to enter Python proper is
	# a demonstration of what happens when there's no code review.
	#
	# This function tries to remove the offending lines from .pth files.
	#
	# See:
	#   http://stackoverflow.com/questions/5984523/eggs-in-path-before-pythonpath-environment-variable
	# for details.
	
	for FN in $(find "$PREFIX" -name "*.pth"); do
		sed -i~ '/^import.*/d' "$FN"
	done
}

default_usage()
{
	cat <<-"EOF"
		pkgbuild -- EupsPkg builder script

		usage: pkgbuild [-ha] [-v verbosity] verb

		  verb  : one of create, fetch, prep, config, build, install

		  v : set verbosity level (-2 through +2, default 0)
		  a : autodetect PRODUCT and VERSION using git
		  d : don't detect for dirty working dir in autodetect
		  f : proceed even if PRODUCT or VERSION are not defined
		  h : show usage instructions

		If run with 'create', the script will create './ups/pkginfo'
		with package configuration, as well as prepare the package
		depending on the chosen SOURCE.

		If run with any other verb, the script will look for
		'./ups/pkginfo' to source the configuration.  This location
		can be overridden via the PKGINFO environment variable.  If
		neither is given, the script will assume the configuration
		is passed via the environment.

		If -a is given a crude auto-detection algorithm will be
		employed to deduce PRODUCT and VERSION from git. This is
		primarily for debugging, and should _never_ be used to
		install packages.

EOF
}

#
# Define default verb implementations
#
create()  { default_create "$@"; }
fetch()   { default_fetch "$@"; }
prep()   { default_prep "$@"; }
config()  { default_config "$@"; }
build()   { default_build "$@"; }
install() { default_install "$@"; }
usage()   { default_usage "$@"; }

##################### ---- DEBUGGING UTILITIES ---- #####################

xcreate()
{
	# Quickly creates the package in _create subdirectory, emptying it
	# first if it already exists.  It's primary purpose is to help
	# testing of create verb implementations.
	#
	# Typical usage:
	#
	#    ./ups/pkgbuild -a xcreate
	#
	# and the result will be in _create
	#

	# create an empty _create subdir
	rm -rf _create
	mkdir _create

	# run create() from the empty directory
	cd _create
	create "$@"

	msg "the result is in ./_create"
}

xfetch()
{
	#
	# Runs fetch() on the package whose contents is in ./_create. 
	# Stores the result into ./_fetch, emptying it first if it already
	# exists.  The primary purpose of this function is to help with
	# testing of fetch verb implementations.
	#
	# Typical usage:
	#
	#    ./ups/pkgbuild xfetch
	#
	# and the result will be in _fetch
	#

	[[ -d _create ]] || die "no _create directory; run '$0 xcreate' first."

	rm -rf _fetch
	cp -a _create _fetch

	_PKGBUILD=$(test -f ./_fetch/ups/pkgbuild && echo "./ups/pkgbuild" || echo "$EUPS_DIR/lib/eupspkg/pkgbuild.default")
	(cd _fetch && $_PKGBUILD -v $VERBOSE fetch)

	msg "the result is in ./_fetch"
}

xclean()
{
	#
	# Clean the outputs of x* verbs
	#

	rm -rf _fetch _create
}

xall()
{
	#
	# Run the full build + declare sequence for a package
	#

	[[ -d ups ]] || die "no ./ups directory. are you in an EUPS package root?"

	setup -r .

	pkgbuild -a -d prep
	pkgbuild -a -d config
	pkgbuild -a -d build
	pkgbuild -a -d install
	pkgbuild -a -d eups_declare

	unsetup -r .
}

##################### ---- INITIALIZATION ---- #####################

#
# Parse command line arguments
#
VERBOSE=${VERBOSE:-0}
DIRTY_FLAG=${DIRTY_FLAG:-"--dirty"}
while getopts ":v:hadf" opt; do
	case $opt in
		v) VERBOSE="$OPTARG" ;;
		a) AUTOVERSION=on ;;
		d) DIRTY_FLAG="" ;;
		f) FORCE=1 ;;
		h) usage; exit; ;;
		\?) die "Invalid option: -$OPTARG" ;;
		:) die "Option -$OPTARG requires an argument." ;;
	esac
done
shift $((OPTIND-1))

if [[ "$AUTOVERSION" == on ]]; then
	autoversion
fi

#
# Debug level 3 activates tracing
#
[[ $VERBOSE -ge 3 ]] && set -x

[[ $# -ge 1 ]] || { error "insufficient number of arguments [$0 "$@"]."; usage; exit -1; }

#
# Source the pkginfo file
#

if [[ "$1" != "create" && "$1" != "xfetch" && "$1" != "xclean" && "$1" != "xall" ]]; then
	if [[ ! -z "$PKGINFO" ]]; then
		debug "sourcing pkginfo from PKGINFO='$PKGINFO'."
		. "$PKGINFO"
	elif [[ -f ups/pkginfo ]]; then
		debug "detected pkginfo in ups/pkginfo."
		PKGINFO=ups/pkginfo
		. "$PKGINFO"
	elif [[ -z "$PRODUCT" || -z "$VERSION" ]]; then
		if [[ $FORCE -ne 1 ]]; then
			die "no './ups/pkginfo' file, and PKGINFO, PRODUCT nor VERSION are defined."
		fi
	fi
fi

#
# Try to figure out how many cores does this machine have, and tweak
# MAKEFLAGS and SCONSFLAGS accordingly
#
use_parallel_jobs $((sysctl -n hw.ncpu || (test -r /proc/cpuinfo && grep processor /proc/cpuinfo | wc -l) || echo 2) 2>/dev/null)

##################### ---- Defaults ---- #####################

SOURCE=${SOURCE:-local}					# [local|git|git-archive]. Usually passed in via command line (eups distrib create ... -S SOURCE=...)
REPOSITORY=${REPOSITORY:-}				# URL to git repository

MAKE_BUILD_TARGETS=${MAKE_BUILD_TARGETS:-}		# Targets for invocation of make in build phase
MAKE_INSTALL_TARGETS=${MAKE_INSTALL_TARGETS:-"install"}	# Targets for invocation of make in test phase

PREFIX=${PREFIX:-"$(eups path 0)/$(eups flavor)/$PRODUCT/$VERSION"}	# Directory to which the product will be installed

CONFIGURE_OPTIONS=${CONFIGURE_OPTIONS:-"--prefix $PREFIX"}			# Options passed to ./configure. Note that --prefix is NOT passed separately!
PYSETUP_INSTALL_OPTIONS=${PYSETUP_INSTALL_OPTIONS:-"--home $PREFIX"}		# Options passed to setup.py install. Note that --home is NOT passed separately!

if [[ -z "$PKGBUILD_SOURCE" ]]; then						# Fully qualified path to pkgbuild script.
	# Last item of BASH_SOURCE is the top-level script we were invoked from
	# Note: this will fail if the script was invoked using a relative path, and
	# $PWD was changed in the meantime. The final statement tries to catch
	# some of these.

	_BS="${BASH_SOURCE[${#BASH_SOURCE[@]}-1]}"
	PKGBUILD_SOURCE="$( cd "$( dirname $_BS )" && pwd )/$(basename "$_BS")"
	if [[ ! -f "$PKGBUILD_SOURCE" ]]; then
		die "failed to deduce the full path to this pkgbuild script. please rerun it using a full path."
	fi
fi
