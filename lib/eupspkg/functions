#!/bin/bash -- just to enable syntax highlighting --
#
# EupsPkg Distrib Mechanism Function Library
#
# Defines utility functions, default implementations of pkgbuild verbs, and
# performs common initialization.
#
# Should be sourced early on in pkgbuild scripts.
#

set -e

##################### ---- UTILITY FUNCTIONS ---- #####################

#
# Verbosity levels:
#
#   >= -3: Show fatal errors (fatal)
#   >= -2: Show errors (error)
#   >= -1: Show warnings (warn)
#   >=  0: Show messages (msg)
#   >=  1: Show add'l informational messages (info)
#   >=  2: Show debugging messages (debug)
#   >=  3: Activate Bash tracing (set -x)

# The funny '|| true' construct is there to ensure this works with 'set -e'
die()   { [[ $VERBOSE -ge -3 ]] && echo "pkgbuild (fatal): $@" >&2 || true; exit -1; }
error() { [[ $VERBOSE -ge -2 ]] && echo "pkgbuild (error): $@" >&2 || true; }
warn()  { [[ $VERBOSE -ge -1 ]] && echo "pkgbuild (warning): $@" >&2 || true; }
msg()   { [[ $VERBOSE -ge 0 ]] && echo "pkgbuild: $@" >&2 || true; }
info()  { [[ $VERBOSE -ge 1 ]] && echo "pkgbuild (info): $@" >&2 || true; }
debug() { [[ $VERBOSE -ge 2 ]] && echo "pkgbuild (debug): $@" >&2 || true; }

die_if_empty() { eval VAL_="\$$1"; if [ -z "$VAL_" ]; then die "$1 is not set. refusing to proceed."; fi; }

append_pkginfo()
{
	# Append VARNAME=VARVALUE line to pkginfo file
	# Should only be used by the 'create' verb.
	#
	# usage: append_pkginfo <VARNAME> [VARVALUE]
	#
	# If VARVALUE is not given $VARNAME will be evaluated
	#

	die_if_empty PKGINFO

	if [[ $# == 1 ]]; then
		eval VAL_="\$$1";
	else
		VAL_="$2"
	fi

	echo $1="'""$VAL_""'" >> "$PKGINFO"
	
	info "appended $1='$VAL_' to pkginfo."
}

use_parallel_jobs()
{
	# Tweak MAKEFLAGS and SCONSFLAGS to run at the given level of parallelism
	#
	# usage: use_parallel_jobs <NJOBS>
	#
	NJOBS=$1

	# Note: If this function is called multiple times, last -j option will take presedence.
	# Not elegant, but works.
	export MAKEFLAGS="$SCONSFLAGS -j $NJOBS"
	export SCONSFLAGS="$SCONSFLAGS -j $NJOBS"

	debug "using $NJOBS parallel jobs."
	debug "  MAKEFLAGS=$MAKEFLAGS"
	debug "  SCONSFLAGS=$SCONSFLAGS"
}

detect_compiler()
{
	#
	# Properly detects C and C++ compiler types. Dies if the two are not
	# the same.
	#
	# Defines:
	#	COMPILER_TYPE, CXX_COMP_TYPE, C_COMP_TYPE
	#

	# Construct test source files
	local S="$(mktemp -t comptest.XXXXX)".c
	cat > "$S" <<-EOF
		#include <stdio.h>

		int main()
		{
			#if defined(__clang__)
				printf("clang");
			#elif defined(__ICC) || defined(__INTEL_COMPILER)
				printf("icc");
			#elif defined(__GNUC__) || defined(__GNUG__)
				printf("gcc");
			#elif defined(_MSC_VER)
				printf("msvc");
			#elif defined(__PGI)
				printf("pgcc");
			#else
				printf("unknown");
			#endif

			return 0;
		}
	EOF
	local SCXX="$(mktemp -t comptest.XXXXX)".cxx
	cp "$S" "$SCXX"

	# Build and run the test
	local O=$(mktemp -t comptest.XXXXX)
	local OCXX=$(mktemp -t comptest.XXXXX)
	CC1="${CC:-cc}"
	CXX1="${CXX:-c++}"
	"$CC1" "$S" -o "$O"
	"$CXX1" "$SCXX" -o "$OCXX"
	C_COMP_TYPE=$("$O")
	CXX_COMP_TYPE=$("$OCXX")

	# Check compiler type consistency
	if [[ "$CXX_COMP_TYPE" != "$C_COMP_TYPE" ]]; then
		die "C and C++ compiler versions differ ($CC1 is of type '$C_COMP_TYPE' while $CXX1 is of type '$CXX_COMP_TYPE')"
	fi

	COMPILER_TYPE="$CXX_COMP_TYPE"
}

autoproduct()
{
	# Guess PRODUCT, assuming we were called from a working directory of
	# a git repository.

	if ! hash git 2>/dev/null; then
		die "could not execute 'git' to automatically deduce PRODUCT and VERSION."
	fi

	local REMOTE=$(git config --get remote.origin.url || true)
	if [[ -z "$REMOTE" ]]; then
		die "No git remote named 'origin', or git error. Please specify PRODUCT.";
	fi

	PRODUCT="$(basename "$REMOTE" .git)"
	msg "guessed PRODUCT='$PRODUCT'"
}

autoversion()
{
	# Guess VERSION, assuming we were called from a working directory of
	# a git repository.

	VERSION="$(pkgautoversion $1)"
	msg "guessed VERSION='$VERSION'"
}

version_to_gitrev()
{
	# Convert VERSION to a git revision that can be pulled with
	# git-clone by removing anything past the first '+', and
	# converting any _ to -.
	#

	local V=${VERSION%%+*}		# remove everything past first + (incl. the '+')
	echo ${V//_/-}			# convert all _ to -
}

eups_declare()
{
	# Make the package known to EUPS
	#
	# NOTE: This function is not a part of the "official" API; it's here just
	# to ease debugging.

	die_if_empty PRODUCT
	die_if_empty VERSION

	# Sanity checks
	if [[ ! -d "$PREFIX/ups" ]]; then
		die "directory $PREFIX doesn't exist or is not a directory. did you forget to run 'pkgbuild install'?"
	fi

	eups declare -c "$PRODUCT" "$VERSION" -r "$PREFIX"
	msg declared "$PRODUCT-$VERSION" in "$PREFIX"
}

install_ups()
{
	# Copy the contents of ups/ to $PREFIX/ups and expand the table files
	#
	# It's necessary to call this if the native install method doesn't
	# copy/expand ups/ content

	[ ! -d ups ] && die "no 'ups' directory to copy to destination (are you running from package root?)";

	mkdir -p "$PREFIX/ups"
	cp -f -a ./ups/* "$PREFIX/ups"

	# Expand the table file, if any
	if [[ -f "$PREFIX/ups/$PRODUCT.table" ]]; then
		eups expandtable -i -W '^(?!LOCAL:)' "$PREFIX/ups/$PRODUCT.table"
		info "expanded table file '$PREFIX/ups/$PRODUCT.table'"
	else
		msg "no table file to expand (looked for '$PREFIX/ups/$PRODUCT.table')".
	fi
}

clean_old_install()
{
	#
	# Remove any existing content in $PREFIX, being extra careful
	# that $PREFIX is sane.
	#
	if [[ -e "$PREFIX" ]]; then
		P0=$(cd "$(eups path 0)/$(eups flavor)" && pwd)
		P1=$(cd "$PREFIX" && pwd)

		# Delete only if $PREFIX is a proper subdirectory of eups
		# install root
		if [[ "$P0" != "$P1" && "$P1" == "$P0"* ]]; then
			msg "deleting existing install in '$P1'"
			rm -rf "$P1"
		else
			msg "odd install directory '$PREFIX' (not a proper subdir of eups install root). not deleting it out of abundance of caution."
		fi
	fi
}

resolve_repository()
{
	#
	# Resolve the path to git repository, by expanding patterns
	# specified on the RESOLVE_PATH.  If unsuccessful, but $REPOSITORY
	# is not empty, use that.  Otherwise, die.
	#
	# RESOLVE_PATH must be of the form:
	#
	#   'git://server1/dirs1/$PRODUCT.git|http://server2/dirs2/$PRODUCT.git'
	#
	# etc., i.e., a |-delimited string of Bash strings which will be eval-ed
	# in the current environment.
	#
	# Defines: REPOSITORY
	#

	IFS='|' read -ra REPOSITORY_PATH_ARRAY <<< "$REPOSITORY_PATH"
	for PAT in "${REPOSITORY_PATH_ARRAY[@]}"; do
		eval "_REPOSITORY=\"$PAT\""
		info "trying $_REPOSITORY"
		if git ls-remote "$_REPOSITORY" master >/dev/null 2>&1; then
			info "repository resolved to $_REPOSITORY."
			REPOSITORY="$_REPOSITORY"
			return
		fi
	done

	if [[ -z "$REPOSITORY" ]]; then
		die "failed to resolve repository for $PRODUCT-$VERSION using REPOSITORY_PATH='$REPOSITORY_PATH'. Check the path or accessibility of your git repositories."
	fi

	info "using predefined REPOSITORY='$REPOSITORY'"
}

contains()
{
	#
	# usage: contains <needle> <haystack[1]> [haystack[2]] ...
	#

	local _N="$1"
	shift

	for _H in "${@}"; do
		[[ $_N == $_H ]] && return 0
	done

	return 250
}

##################### ---- DEFAULT VERB IMPL ---- #####################

default_create()
{
	# Called to publish the package to the distribution server
	# Should generate all the files that are needed for cloning
	# --
	# CWD: Called from $pkgroot
	# Env: Nothing guaranteed to be setup-ed
	#

	# safety: refuse to work in a directory containing anything other than 'ups'
	# subdirectory. This will prevent chaos when careless users run pkgbuild create
	# in their source directories.
	if [[ ! -z "$(ls -A)" ]]; then
		die "safety first: refusing to run from a non-empty directory."
	fi

	# Make sure the important ones are here
	die_if_empty PRODUCT
	die_if_empty VERSION
	die_if_empty FLAVOR
	die_if_empty SOURCE

	# Define temporary location for pkginfo file. We'll copy
	# it to ups/pkginfo in the end, to avoid it being overwritten
	# by package creation commands below.
	PKGINFO=$(mktemp -t pkginfo.XXXXX)

	# Store the variables we know of to pkginfo
	append_pkginfo PRODUCT
	append_pkginfo VERSION
	append_pkginfo FLAVOR
	append_pkginfo SOURCE

	# Prepare the package
	resolve_repository

	# Use any SHA1 that was passed in (from pkginfo or command line), or version
	GITREV=${SHA1:-$(version_to_gitrev)}

	case "$SOURCE" in
		git)
			# Use git clone to extract ups/pkgbuild. Store the SHA1 into $PKGINFO
			# Note: this is terribly inefficient, but git doesn't provide a
			# mechanism to just fetch a single file given a ref.
			git clone --shared -n -q "$REPOSITORY" tmp

			# try to avoid checking out everything (it may be a multi-GB repo)
			(cd tmp && { git checkout -q $GITREV -- ups 2>/dev/null || git checkout -q $GITREV; })

			SHA1=$(cd tmp && git rev-parse HEAD)
			append_pkginfo SHA1

			mkdir ups
			if [[ -e tmp/ups/pkgbuild ]]; then
				mv tmp/ups/pkgbuild ups
			fi

			rm -rf tmp
			;;
		git-archive)
			# Extract ups/pkgbuild using git-archive
			git archive --format=tar.gz --remote="$REPOSITORY" "$VERSION" ups/pkgbuild 2>/dev/null | (tar xzf - 2>/dev/null || true)
			# note: the odd tar construct (and PIPESTATUS check) is to account for BSD/gnu tar differences:
			#       BSD tar returns success on broken pipe, gnu tar returns an error.
			if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
				# The failure may have occurred because ups/ does not exist on the remote, or because
				# of a problem with accessing the repository. The former is legal, the latter is not.
				# Find out which one is it and act accordinly.
				git archive --format=tar.gz --remote="$REPOSITORY" "$VERSION" | head -c 1 > /dev/null
				if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
					die "could not access '$REPOSITORY' via git-archive. has it been tagged with '$VERSION'"?
				fi
			fi
			mkdir -p ups
			;;
		"local")
			# Extract the full source using git-archive, falling back to git-clone in case of failure.
			git archive --format=tar.gz --remote="$REPOSITORY" "$VERSION" 2>/dev/null | (tar xzf - 2>/dev/null || true)
			# note: the odd tar construct (and PIPESTATUS check) is to account for BSD/gnu tar differences:
			#       BSD tar returns success on broken pipe, gnu tar returns an error.
			if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
				git clone --shared -n -q "$REPOSITORY" .
				git checkout -q $GITREV

				SHA1=$(git rev-parse HEAD)
				append_pkginfo SHA1

				rm -rf .git
			fi
			;;
		*)
			echo "pkgbuild error: unknown source download mechanism SOURCE='$SOURCE' (known mechanisms: git, git-archive, local)."; exit -1;
	esac

	# if $REPOSITORY is a local directory, see if there's a remote named
	# 'origin' and use it for repository URL.  Otherwise, store as-is.
	if [[ -d "$REPOSITORY" ]]; then
		local URL=$(cd "$REPOSITORY" && git config --get remote.origin.url)
		if [[ ! -z "$URL" ]]; then
			info "detected '$REPOSITORY' is local; recording '$URL' in pkginfo (url of orgin)"
			REPOSITORY="$URL"
		fi
	fi
	append_pkginfo REPOSITORY

	# move pkginfo file to its final location
	mkdir -p ups
	mv "$PKGINFO" ups/pkginfo
	chmod +r ups/pkginfo

	PKGINFO="ups/pkginfo"

	msg "package contents created for '$PRODUCT-$VERSION', with sources in '$SOURCE'."
}

default_fetch()
{
	# Should obtain the source and unpack it so it's the same
	# as when it was checked out from git. The source should be unpacked to
	# $pkgroot/build
	# --
	# Called by 'eups distrib install <pkgname> <version>'
	# --
	# CWD: Called from $pkgroot
	# Env: Called in environment with setup-ed dependencies, but not the package itself
	#

	die_if_empty PRODUCT
	die_if_empty VERSION

	case "$SOURCE" in
		git)
			# Obtain the source from a git repository
			die_if_empty REPOSITORY
			die_if_empty SHA1

			info "fetching by git cloning from $REPOSITORY"
			git clone -q "$REPOSITORY" tmp
			(cd tmp && git checkout -q $SHA1)

			rm -rf tmp/.git

			# move everything but the contents of the ups directory (as it already exists)
			find tmp -maxdepth 1 -mindepth 1 ! -name ups -exec mv {} . \;
			# move the contents of the ups directory, excluding pkgbuild and pkginfo
			find tmp/ups -maxdepth 1 -mindepth 1 ! \(  -name pkgbuild -o -name pkginfo \) -exec mv {} ups \;
			rm -f tmp/ups/pkgbuild tmp/ups/pkginfo
			rmdir tmp/ups 2>/dev/null || true

			# the tmp directory must be empty at this point
			rmdir tmp
			;;
		git-archive)
			die_if_empty REPOSITORY
			die_if_empty VERSION
			# note: the odd tar construct (and PIPESTATUS check) is to account for BSD/gnu tar differences:
			#       BSD tar returns success on broken pipe, gnu tar returns an error.

			info "fetching via git-archive from $REPOSITORY"
			git archive --format=tar.gz  --remote="$REPOSITORY" "$VERSION" | (tar xzf - --exclude ups/pkgbuild --exclude ups/pkginfo 2>/dev/null || true)
			if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
				die could not access "$REPOSITORY" via git-archive. has it been tagged with "$VERSION"?
			fi
			;;
		"local")
			;;
		*)
			die "unknown source '$SOURCE'. Malformed archive?";
			;;
	esac
}

default_prep()
{
	# Should apply any patches and prepare the code to be configured
	# --
	# Called by 'eups distrib install <pkgname> <version>'
	# Caller: buildbot, to prep the package for configuration
	# --
	# CWD: Called from $builddir
	# Env: Called in environment with setup-ed dependencies, but not the package itself
	# --
	# Typical override:
	#   apply applicable patches from $sourcedir/patches, depending
        #   on platform we're being compiled on.

	:
}

default_config()
{
	# Should apply any patches and configure the code to be built using build()
	# --
	# Called by 'eups distrib install <pkgname> <version>'
	# Caller: buildbot, to prep the package for building
	# --
	# CWD: Called from $builddir
	# Env: Called in environment with setup-ed dependencies, but not the package itself
	# --
	# Typical override:
	#   run custom configuration scripts

	if [[ -f configure ]]; then
		./configure $CONFIGURE_OPTIONS
	fi
}

default_build()
{
	# Called to build the package.
	# --
	# Caller: 'eups distrib install <pkgname> <version>'
	# Caller: buildbot, to build the package
	# --
	# CWD: Called from $builddir
	# Env: Called in environment with setup-ed dependencies, including self

	die_if_empty PRODUCT
	die_if_empty VERSION

	#
	# Attempt to autodetect the build system
	#
	if [[ -f SConstruct ]]; then
		scons opt=3 prefix="$PREFIX" version="$VERSION"
	elif [[ -f configure ]]; then
		make prefix="$PREFIX" version="$VERSION" $MAKE_BUILD_TARGETS
	elif [[ -f Makefile || -f makefile || -f GNUmakefile ]]; then
		make prefix="$PREFIX" version="$VERSION" $MAKE_BUILD_TARGETS
	elif [[ -f setup.py ]]; then
		python setup.py build
	else
		msg "no build system detected; assuming no build needed."
	fi
}

default_install()
{
	# Called to install the package, and declare it to EUPS
	# --
	# Caller: 'eups distrib install <pkgname> <version>'
	# Caller: buildbot, to build the package
	# --
	# CWD: Called from $builddir
	# Env: Called in environment with setup-ed dependencies, including self

	die_if_empty PRODUCT
	die_if_empty VERSION

	clean_old_install

	#
	# Attempt to autodetect the build system
	#
	if [[ -f SConstruct ]]; then
		scons opt=3 prefix="$PREFIX" version="$VERSION" install
	elif [[ -f Makefile || -f makefile || -f GNUmakefile ]]; then
		make prefix="$PREFIX" version="$VERSION"  $MAKE_INSTALL_TARGETS
		install_ups
	elif [[ -f setup.py ]]; then
		PYDEST="$PREFIX/lib/python"
		mkdir -p "$PYDEST"
		PYTHONPATH="$PYDEST:$PYTHONPATH" python setup.py install $PYSETUP_INSTALL_OPTIONS
		evil_setuptools_pth_fix "$PYDEST"
		install_ups
	else
		# just copy everything
		mkdir -p "$PREFIX"
		cp -a ./ "$PREFIX"
		msg "Copied the product into '$PREFIX'"
	fi
}

evil_setuptools_pth_fix()
{
	# setuptools does the *IDIOTIC* sys.path manipulation in .pth files,
	# to prepend its own path to sys.path thus making it impossible to
	# override.  The fact this lunacy managed to enter Python proper is
	# a demonstration of what happens when there's no code review.
	#
	# This function tries to remove the offending lines from .pth files.
	#
	# See:
	#   http://stackoverflow.com/questions/5984523/eggs-in-path-before-pythonpath-environment-variable
	# for details.
	
	for FN in $(find "$PREFIX" -name "*.pth"); do
		sed -i~ '/^import.*/d' "$FN"
	done
}

default_usage()
{
	cat <<-"EOF"
		pkgbuild -- EupsPkg builder script

		usage: pkgbuild [-dh] [-v level] [VAR1=..] [VAR2=..] verb

		  verb  : one of create, fetch, prep, config, build, install

		  v : set verbosity level (-2 through +3, default 0)
		  d : don't check for dirty working dir in version autodet.
		  h : show usage instructions

		If run with 'create', the script will create './ups/pkginfo'
		with package configuration, as well as prepare the package
		depending on the chosen SOURCE.  Any existing
		$PREFIX/ups/pkginfo will be sourced to deduce REPOSITORY and
		SHA1.

		If run with any other verb, the script will look for
		'./ups/pkginfo' to source the configuration.  If it does not
		exist, the script will assume the configuration is passed
		via the environment and attempt to guess PRODUCT and VERSION
		using git.

		Variables can be passed on the command line, after the
		options and before the verb.  These override any from the
		environment or pkginfo.

EOF
}

#
# Define default verb implementations
#
create()  { default_create "$@"; }
fetch()   { default_fetch "$@"; }
prep()    { default_prep "$@"; }
config()  { default_config "$@"; }
build()   { default_build "$@"; }
install() { default_install "$@"; }
usage()   { default_usage "$@"; }

##################### ---- DEBUGGING UTILITIES ---- #####################

xcreate()
{
	# Quickly creates the package in _create subdirectory, emptying it
	# first if it already exists.  It's primary purpose is to help
	# testing of create verb implementations.
	#
	# Typical usage:
	#
	#    ./ups/pkgbuild xcreate
	#
	# and the result will be in _create
	#

	# create an empty _create subdir
	rm -rf _create
	mkdir _create

	# run create() from the empty directory
	cd _create
	create "$@"

	msg "the result is in ./_create"
}

xfetch()
{
	#
	# Runs fetch() on the package whose contents is in ./_create. 
	# Stores the result into ./_fetch, emptying it first if it already
	# exists.  The primary purpose of this function is to help with
	# testing of fetch verb implementations.
	#
	# Typical usage:
	#
	#    ./ups/pkgbuild xfetch
	#
	# and the result will be in _fetch
	#

	[[ -d _create ]] || die "no _create directory; run '$0 xcreate' first."

	rm -rf _fetch
	cp -a _create _fetch

	_PKGBUILD=$(test -f ./_fetch/ups/pkgbuild && echo "./ups/pkgbuild" || echo "$EUPS_DIR/lib/eupspkg/pkgbuild.default")
	(cd _fetch && $_PKGBUILD -v $VERBOSE fetch)

	msg "the result is in ./_fetch"
}

xclean()
{
	#
	# Clean the outputs of x* verbs
	#

	rm -rf _fetch _create
}

xmake()
{
	#
	# Run the full prep+config+build+install sequence for a package
	#

	[[ -d ups ]] || die "no ./ups directory. are you in an EUPS package root?"

	setup -r .

	pkgbuild -a -d prep
	pkgbuild -a -d config
	pkgbuild -a -d build
	pkgbuild -a -d install

	unsetup -r .
}

xall()
{
	#
	# Run the full build + declare sequence for a package
	#

	[[ -d ups ]] || die "no ./ups directory. are you in an EUPS package root?"

	setup -r .

	pkgbuild -a -d prep
	pkgbuild -a -d config
	pkgbuild -a -d build
	pkgbuild -a -d install
	pkgbuild -a -d eups_declare

	unsetup -r .
}

##################### ---- INITIALIZATION ---- #####################

#
# Parse command line options
#
VERBOSE=${VERBOSE:-0}
DIRTY_FLAG=${DIRTY_FLAG:-"--dirty"}
while getopts ":v:hadf" opt; do
	case $opt in
		v) VERBOSE="$OPTARG" ;;
		d) DIRTY_FLAG="" ;;
		h) usage; exit; ;;
		\?) die "Invalid option: -$OPTARG" ;;
		:) die "Option -$OPTARG requires an argument." ;;
	esac
done
shift $((OPTIND-1))

# Peek if PREFIX or VERBOSE were given on the command line (to correctly
# find pkginfo). Inelegant, but effective...
for _V in "$@"; do
	[[ ! $_V =~ [A-Za-z0-9_]+=.* ]] && break	# stop on first non-assignment
	[[ ! $_V =~ (PREFIX|VERBOSE)=.* ]] && continue	# skip all but PREFIX and VERBOSE

	_KEY="${_V%%=*}"
	_VAL="${_V#*=}"
	eval "$_KEY='$_VAL'"
done

#
# Debug level 3 activates tracing
#
[[ $VERBOSE -ge 3 ]] && set -x

#
# Source the pkginfo file
#
# EupsPkg API: PREFIX will be set when 'create' is called, pointing to the installed package
# pkgbuild uses it to locate pkginfo (assumes . as the default)
if [[ -f "${PREFIX:-.}/ups/pkginfo" ]]; then
	debug "found pkginfo in ${PREFIX:-.}/ups/pkginfo."
	. "${PREFIX:-.}/ups/pkginfo"
fi

#
# Variables can be set on the command line, to override anything already in
# the environment or (more interestingly) set via pkginfo. Set them here.
#
while [[ $1 =~ [A-Za-z0-9_]+=.* ]]; do
	_KEY="${1%%=*}"
	_VAL="${1#*=}"
	eval "$_KEY='$_VAL'"
	shift
done

# OK with the remaining number of arguments?
[[ $# -ge 1 ]] || { error "insufficient number of arguments."; usage; exit -1; }

#
# Set up the key variables, but refuse to do it for EupsPkg API verbs where
# we expect them to be set explicitly.  Also skip auto* for some x* verbs
# where we know it's not needed.
#
EUPSPKPG_VERBS="create fetch prep config build install"
NOVERCHECK_VERBS="xfetch xclean"
if ! contains "$1" $EUPSPKG_VERBS $NOVERCHECK_VERBS; then
	[ -z "$PRODUCT" ] && autoproduct
	[ -z "$VERSION" ] && autoversion $DIRTY_FLAG
	FLAVOR=${FLAVOR:-generic}
fi

if [[ -z "$PRODUCT" || -z "$VERSION" ]]; then
	if ! contains "$1" $NOVERCHECK_VERBS; then
		die "PRODUCT or VERSION were not defined. refusing to proceed."
	fi
fi

#
# Try to figure out how many cores does this machine have, and tweak
# MAKEFLAGS and SCONSFLAGS accordingly
#
use_parallel_jobs $((sysctl -n hw.ncpu || (test -r /proc/cpuinfo && grep processor /proc/cpuinfo | wc -l) || echo 2) 2>/dev/null)

##################### ---- Defaults ---- #####################

SOURCE=${SOURCE:-local}					# [local|git|git-archive]. Usually passed in via command line (eups distrib create ... -S SOURCE=...)
REPOSITORY=${REPOSITORY:-}				# URL to git repository

MAKE_BUILD_TARGETS=${MAKE_BUILD_TARGETS:-}		# Targets for invocation of make in build phase
MAKE_INSTALL_TARGETS=${MAKE_INSTALL_TARGETS:-"install"}	# Targets for invocation of make in test phase

PREFIX=${PREFIX:-"$(eups path 0)/$(eups flavor)/$PRODUCT/$VERSION"}	# Directory to which the product will be installed

CONFIGURE_OPTIONS=${CONFIGURE_OPTIONS:-"--prefix $PREFIX"}			# Options passed to ./configure. Note that --prefix is NOT passed separately!
PYSETUP_INSTALL_OPTIONS=${PYSETUP_INSTALL_OPTIONS:-"--home $PREFIX"}		# Options passed to setup.py install. Note that --home is NOT passed separately!

