#!/bin/bash -- just to enable syntax highlighting --
#
# EupsPkg Distrib Mechanism Function Library
#
# Defines utility functions, default implementations of pkgbuild verbs, and
# performs common initialization.
#
# Should be sourced early on in pkgbuild scripts.
#

set -e

##################### ---- UTILITY FUNCTIONS ---- #####################

#
# Verbosity levels:
#
#   >= -3: Show fatal errors (fatal)
#   >= -2: Show errors (error)
#   >= -1: Show warnings (warn)
#   >=  0: Show messages (msg)
#   >=  1: Show add'l informational messages (info)
#   >=  2: Show debugging messages (debug)
#   >=  3: Activate Bash tracing (set -x)

# The funny '|| true' construct is there to ensure this works with 'set -e'
die()   { [[ $VERBOSE -ge -3 ]] && echo "pkgbuild (fatal): $@" >&2 || true; exit -1; }
error() { [[ $VERBOSE -ge -2 ]] && echo "pkgbuild (error): $@" >&2 || true; }
warn()  { [[ $VERBOSE -ge -1 ]] && echo "pkgbuild (warning): $@" >&2 || true; }
msg()   { [[ $VERBOSE -ge 0 ]] && echo "pkgbuild: $@" >&2 || true; }
info()  { [[ $VERBOSE -ge 1 ]] && echo "pkgbuild (info): $@" >&2 || true; }
debug() { [[ $VERBOSE -ge 2 ]] && echo "pkgbuild (debug): $@" >&2 || true; }

die_if_empty() { eval VAL_="\$$1"; if [ -z "$VAL_" ]; then die "$1 is not set. refusing to proceed."; fi; }

append_pkginfo()
{
	# Append VARNAME=VARVALUE line to pkginfo file
	# Should only be used by the 'create' verb.
	#
	# usage: append_pkginfo <VARNAME> [VARVALUE]
	#
	# If VARVALUE is not given $VARNAME will be evaluated
	#

	die_if_empty PKGINFO

	if [[ $# == 1 ]]; then
		eval VAL_="\$$1";
	else
		VAL_="$2"
	fi

	echo $1="'""$VAL_""'" >> "$PKGINFO"
	
	info "appended $1='$VAL_' to pkginfo."
}

use_parallel_jobs()
{
	# Tweak MAKEFLAGS and SCONSFLAGS to run at the given level of parallelism
	#
	# usage: use_parallel_jobs <NJOBS>
	#
	NJOBS=$1

	# Note: If this function is called multiple times, last -j option will take presedence.
	# Not elegant, but works.
	export MAKEFLAGS="$SCONSFLAGS -j $NJOBS"
	export SCONSFLAGS="$SCONSFLAGS -j $NJOBS"

	info "Using $NJOBS parallel jobs."
	debug "  MAKEFLAGS=$MAKEFLAGS"
	debug "  SCONSFLAGS=$SCONSFLAGS"
}

make_targets()
{
	# Run "make <target>" for each argument, with PRODUCT and VERSION exported
	for target in "$@"; do
		PRODUCT="$PRODUCT" VERSION="$VERSION" FLAVOR="$FLAVOR" make $target
	done
}

##################### ---- DEFAULT VERB IMPL ---- #####################

default_create()
{
	# Called to publish the package to the distribution server
	# Should generate all the files that are needed for cloning
	# --
	# CWD: Called from $pkgroot
	# Env: Nothing guaranteed to be setup-ed
	#

	die_if_empty PRODUCT
	die_if_empty VERSION

	# safety: refuse to work in a directory containing anything other than 'ups'
	# subdirectory. This will prevent chaos when careless users run pkgbuild create
	# in their source directories.
	if [[ ! -z "$(ls -A -1 | grep -v '^ups')" ]]; then
		die "safety first: refusing to run from a directory containing anything other than 'ups' subdirectory."
	fi

	case "$FETCH_TYPE" in
		git-archive)
			[[ ! -z "$REPOSITORY" ]] || { echo "pkgbuild error: $REPOSITORY must be set for FETCH_TYPE='$FETCH_TYPE' type."; exit -1; }
			git archive --format=tar.gz --prefix "$FQNAME/" --remote="$REPOSITORY" "$VERSION" ups/pkgbuild > /dev/null ||
				die "git-archive failed trying to check out $VERSION (do you need to tag it?)"
			;;
		tar.gz)
			[[ ! -z "$REPOSITORY" ]] || { echo "pkgbuild error: $REPOSITORY must be set for FETCH_TYPE='$FETCH_TYPE' type."; exit -1; }
			TARBALL="$FQNAME.tar.gz"
			git archive --format=tar.gz --prefix "$FQNAME/" --remote="$REPOSITORY" "$VERSION" --output "$TARBALL"
			append_pkginfo TARBALL "$TARBALL"
			;;
		inline|"")
			[[ ! -z "$REPOSITORY" ]] || { echo "pkgbuild error: $REPOSITORY must be set for FETCH_TYPE='$FETCH_TYPE' type."; exit -1; }
			git archive --format=tar.gz --remote="$REPOSITORY" "$VERSION" | tar xzf - --exclude ups/pkgbuild --exclude ups/pkginfo
			;;
		*)
			echo "pkgbuild error: unknown source type FETCH_TYPE='$FETCH_TYPE'."; exit -1;
	esac
	
	msg "package contents created for $PRODUCT-$VERSION."
}

default_fetch()
{
	# Should obtain the source and unpack it so it's the same
	# as when it was checked out from git. The source should be unpacked to
	# $pkgroot/build
	# --
	# Called by 'eups distrib install <pkgname> <version>'
	# --
	# CWD: Called from $pkgroot
	# Env: Called in environment with setup-ed dependencies, but not the package itself
	#

	die_if_empty PRODUCT
	die_if_empty VERSION

	case "$FETCH_TYPE" in
		git-archive)
			git archive --format=tar.gz  --remote="$REPOSITORY" "$VERSION" | tar xzf - --exclude ups/pkgbuild --exclude ups/pkginfo
			;;
		tar.gz)
			tar xzf "$TARBALL" --strip-components 1 --exclude "$FQNAME/ups/pkgbuild" --exclude "$FQNAME/ups/pkginfo"
			;;
		inline|"")
			;;
		*)
			echo "Unknown source '$FETCH_TYPE'. Malformed archive?"; exit -1;
			;;
	esac
}

default_prep()
{
	# Should apply any patches and prepare the code to be built using build()
	# --
	# Called by 'eups distrib install <pkgname> <version>'
	# Caller: buildbot, to prep the package for building
	# --
	# CWD: Called from $builddir
	# Env: Called in environment with setup-ed dependencies, but not the package itself
	# --
	# Typical override:
	#   apply applicable patches from $sourcedir/patches, depending
        #   on platform we're being compiled on.
        :
}

default_build()
{
	# Called to build the package.
	# --
	# Caller: 'eups distrib install <pkgname> <version>'
	# Caller: buildbot, to build the package
	# --
	# CWD: Called from $builddir
	# Env: Called in environment with setup-ed dependencies, including self

	die_if_empty PRODUCT
	die_if_empty VERSION

	echo PREFIX="$PREFIX"

	#
	# Attempt to autodetect the build system
	#
	if [[ -f SConstruct ]]; then
		scons opt=3 prefix="$PREFIX" version="$VERSION" build
	elif [[ -f configure ]]; then
		./configure --prefix "$PREFIX"
		make_targets $MAKE_BUILD_TARGETS
	elif [[ -f Makefile ]]; then
		make_targets $MAKE_BUILD_TARGETS
	else
		msg "No build system detected; assuming no build needed."
	fi
}

install_ups()
{
	die_if_empty PKGINFO
	[ ! -d ups ] && die "no 'ups' directory to copy to destination (are you running from package root?)";

	mkdir -p "$PREFIX/ups"
	cp -f -a ./ups/* "$PREFIX/ups"
}

default_install()
{
	# Called to install the package, and declare it to EUPS
	# --
	# Caller: 'eups distrib install <pkgname> <version>'
	# Caller: buildbot, to build the package
	# --
	# CWD: Called from $builddir
	# Env: Called in environment with setup-ed dependencies, including self

	die_if_empty PRODUCT
	die_if_empty VERSION

	#
	# Attempt to autodetect the build system
	#
	if [[ -f SConstruct ]]; then
		scons opt=3 prefix="$PREFIX" version="$VERSION" install
	elif [[ -f Makefile ]]; then
		make_targets $MAKE_INSTALL_TARGETS
		install_ups
	else
		# just copy everything
		mkdir -p "$PREFIX"
		cp -a ./ "$PREFIX"
		# if this was a tarball install, remove the tarball
		[ ! -z "$TARBALL" ] && rm "$PREFIX/$TARBALL"
		msg "Copied the product into '$PREFIX'"
	fi
}

default_usage()
{
	cat <<-"EOF"
		pkgbuild -- EupsPkg builder script

		usage: pkgbuild [-h] [-v verbosity] pkginfo verb

		  optinfo : location of pkginfo or 'none' to skip
		  verb    : one of create, fetch, prep, build, install

		  v : set verbosity level (-2 through +2, default 0)
		  h : show usage instructions

		If pkginfo is set to 'auto', a crude auto-detection
		algorithm will be employed to deduce PRODUCT and VERSION
		using git (this should _never_ be used to create packages).

EOF
}

#
# Define default verb implementations
#
create()  { default_create "$@"; }
fetch()   { default_fetch "$@"; }
prep()    { default_prep "$@"; }
build()   { default_build "$@"; }
install() { default_install "$@"; }
usage()   { default_usage "$@"; }

##################### ---- INITIALIZATION ---- #####################

#
# Parse command line arguments
#
VERBOSE=${VERBOSE:-0}
while getopts ":v:h" opt; do
	case $opt in
		v) VERBOSE="$OPTARG" ;;
		h) usage; exit; ;;
		\?) die "Invalid option: -$OPTARG" ;;
		:) die "Option -$OPTARG requires an argument." ;;
	esac
done
shift $((OPTIND-1))

#
# Debug level 3 activates tracing
#
[[ $VERBOSE -ge 3 ]] && set -x

[[ $# -ge 2 ]] || { error "insufficient number of arguments [$0 "$@"]."; usage; exit -1; }

#
# Defaults the user (or pkginfo) can override
#
FETCH_TYPE=${FETCH_TYPE:-inline}			# [|inline|git-archive|tar.gz]. Usually passed in via command line (eups distrib create ... -S FETCH_TYPE=...)
REPOSITORY=${REPOSITORY:-}				# URL to git repository
MAKE_BUILD_TARGETS=${MAKE_BUILD_TARGETS:-"all test"}	# Targets for invocation of make in build phase
MAKE_INSTALL_TARGETS=${MAKE_INSTALL_TARGETS:-"install"}	# Targets for invocation of make in test phase

#
# Source the pkginfo file
#
PKGINFO="$1"
shift
if [[ $PKGINFO == auto ]]; then
	# Heuristics to guess PRODUCT/VERSION, assuming we were called from
	# a working directory of a git repository.
	#
	# This exists primarily to enable debugging.
	if hash git 2>/dev/null; then
		PRODUCT="$(basename $(git config --get remote.origin.url) .git)"
		VERSION="$(git describe --always --dirty)"
		FLAVOR=generic

		PKGINFO=$(mktemp -t pkginfo)
		append_pkginfo PRODUCT
		append_pkginfo VERSION
		append_pkginfo FLAVOR

		warn "temporary pkginfo file created in $PKGINFO"
		warn "used git heuristics to deduce \$PRODUCT and \$VERSION."
		warn "    auto-determined: PRODUCT=$PRODUCT"
		warn "    auto-determined: VERSION=$VERSION"
		warn "    assumed:         FLAVOR=$FLAVOR"

	else
		die "could not execute 'git' to automatically deduce PRODUCT and VERSION."
	fi
else
	. "$PKGINFO"
fi

# Check for basic sanity. Don't die, as this may just be a power user
# writing a very weird pkgbuild script.
[[ -z "$VERSION" ]] && warn "VERSION not defined. hope you know what you're doing."
[[ -z "$PRODUCT" ]] && warn "PRODUCT not defined. hope you know what you're doing."

#
# Try to figure out how many cores does this machine have, and tweak
# MAKEFLAGS and SCONSFLAGS accordingly
#
use_parallel_jobs $((sysctl -n hw.ncpu || (test -r /proc/cpuinfo && grep processor /proc/cpuinfo | wc -l) || echo 2) 2>/dev/null)

#
# Define frequently used computed variables
#
PREFIX=${PREFIX:-"$(eups path 0)/$(eups flavor)/$PRODUCT/$VERSION"}
FQNAME=${FQNAME:-"$PRODUCT-$VERSION"}
