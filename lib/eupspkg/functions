#!/bin/bash -- just to enable syntax highlighting --
#
# EupsPkg Distrib Mechanism Function Library
#
# Defines utility functions, default implementations of pkgbuild verbs, and
# performs common initialization.
#
# Should be sourced early on in pkgbuild scripts.
#

#TODO: Rename SOURCE to something better

set -e

##################### ---- UTILITY FUNCTIONS ---- #####################

#
# Verbosity levels:
#
#   >= -3: Show fatal errors (fatal)
#   >= -2: Show errors (error)
#   >= -1: Show warnings (warn)
#   >=  0: Show messages (msg)
#   >=  1: Show add'l informational messages (info)
#   >=  2: Show debugging messages (debug)
#   >=  3: Activate Bash tracing (set -x)

# The funny '|| true' construct is there to ensure this works with 'set -e'
die()   { [[ $VERBOSE -ge -3 ]] && echo "pkgbuild (fatal): $@" >&2 || true; exit -1; }
error() { [[ $VERBOSE -ge -2 ]] && echo "pkgbuild (error): $@" >&2 || true; }
warn()  { [[ $VERBOSE -ge -1 ]] && echo "pkgbuild (warning): $@" >&2 || true; }
msg()   { [[ $VERBOSE -ge 0 ]] && echo "pkgbuild: $@" >&2 || true; }
info()  { [[ $VERBOSE -ge 1 ]] && echo "pkgbuild (info): $@" >&2 || true; }
debug() { [[ $VERBOSE -ge 2 ]] && echo "pkgbuild (debug): $@" >&2 || true; }

die_if_empty() { eval VAL_="\$$1"; if [ -z "$VAL_" ]; then die "$1 is not set. refusing to proceed."; fi; }

append_pkginfo()
{
	# Append VARNAME=VARVALUE line to pkginfo file
	# Should only be used by the 'create' verb.
	#
	# usage: append_pkginfo <VARNAME> [VARVALUE]
	#
	# If VARVALUE is not given $VARNAME will be evaluated
	#

	die_if_empty PKGINFO

	if [[ $# == 1 ]]; then
		eval VAL_="\$$1";
	else
		VAL_="$2"
	fi

	echo $1="'""$VAL_""'" >> "$PKGINFO"
	
	info "appended $1='$VAL_' to pkginfo."
}

use_parallel_jobs()
{
	# Tweak MAKEFLAGS and SCONSFLAGS to run at the given level of parallelism
	#
	# usage: use_parallel_jobs <NJOBS>
	#
	NJOBS=$1

	# Note: If this function is called multiple times, last -j option will take presedence.
	# Not elegant, but works.
	export MAKEFLAGS="$SCONSFLAGS -j $NJOBS"
	export SCONSFLAGS="$SCONSFLAGS -j $NJOBS"

	info "Using $NJOBS parallel jobs."
	debug "  MAKEFLAGS=$MAKEFLAGS"
	debug "  SCONSFLAGS=$SCONSFLAGS"
}

make_targets()
{
	# If called w/o arguments, call make w/o a target
	if [[ $# == 0 ]]; then
		PRODUCT="$PRODUCT" VERSION="$VERSION" FLAVOR="$FLAVOR" make
	else
		# Run "make <target>" for each argument, with PRODUCT and VERSION exported
		for target in "$@"; do
			PRODUCT="$PRODUCT" VERSION="$VERSION" FLAVOR="$FLAVOR" make $target
		done
	fi
}

autoversion()
{
	# Heuristics to guess PRODUCT/VERSION, assuming we were called from
	# a working directory of a git repository.
	#
	# This exists primarily to enable debugging.
	if hash git 2>/dev/null; then
		warn "using git heuristics to deduce pkginfo contents."

		FLAVOR=generic
		REMOTE=$(git config --get remote.origin.url || true)
		if [[ -z "$REMOTE" ]]; then
			die "No git remote named 'origin', or git error.";
		fi

		PRODUCT="$(basename "$REMOTE" .git)"

		# Construct an EUPS-friendly version string based on git info
		# Does not encode dependencies in version (no +N part)
		VERSION="$(git describe --long --always --dirty | tr - _)"

		warn "    auto-determined: PRODUCT=$PRODUCT"
		warn "    auto-determined: VERSION=$VERSION"
		warn "    assumed:         FLAVOR=$FLAVOR"
	else
		die "could not execute 'git' to automatically deduce PRODUCT and VERSION."
	fi
}

version_to_git_rev()
{
	# Parse a git SHA out of the version, that can be pulled with git-clone
	#
	# Assume the versions are of the form:
	#
	#    <tag>:<n>:<sha1>:[dirty][+...]
	#
	# If the version can't be parsed, return it as-is (it may be a tag).
	#
	# Defines: GITREV
	#

	#VERSION="6.2.0.0:10:g4707c82"
	#VERSION="4707c82:dirty"

	local VER=$(echo "$VERSION" | cut -d+ -f 1)
	local SHA=$(echo "$VER" | cut -d: -f 3)
	local NF=$(echo "$VER" | grep -o : | wc -l)

	if [[ $NF -ne 2 || "${SHA:0:1}" != "g" || "$VER" = *:dirty ]]; then
		GITREV="$(echo "$VER" | tr _ -)"
	else
		GITREV=${SHA:1}
	fi
	#echo GITREV=$GITREV VER=$VER NF=$NF
	#exit -1
}

eups_declare()
{
	# Make the package known to EUPS
	#
	# NOTE: This function is not a part of the "official" API; it's here just
	# to ease debugging.

	die_if_empty PRODUCT
	die_if_empty VERSION

	# Sanity checks
	if [[ ! -d "$PREFIX/ups" ]]; then
		die "directory $PREFIX doesn't exist or is not a directory. did you forget to run 'pkgbuild install'?"
	fi

	eups declare -c "$PRODUCT" "$VERSION" -r "$PREFIX"
}

##################### ---- DEFAULT VERB IMPL ---- #####################

default_create()
{
	# Called to publish the package to the distribution server
	# Should generate all the files that are needed for cloning
	# --
	# CWD: Called from $pkgroot
	# Env: Nothing guaranteed to be setup-ed
	#

	# safety: refuse to work in a directory containing anything other than 'ups'
	# subdirectory. This will prevent chaos when careless users run pkgbuild create
	# in their source directories.
	if [[ ! -z "$(ls -A)" ]]; then
		die "safety first: refusing to run from a non-empty directory."
	fi

	# Make sure the important ones are here
	die_if_empty PRODUCT
	die_if_empty VERSION
	die_if_empty FLAVOR
	die_if_empty SOURCE

	# Define temporary location for pkginfo file. We'll copy
	# it to ups/pkginfo in the end, to avoid it being overwritten
	# by package creation commands below.
	PKGINFO=$(mktemp -t pkginfo)

	# Store the variables we know of to pkginfo
	append_pkginfo PRODUCT
	append_pkginfo VERSION
	append_pkginfo FLAVOR
	append_pkginfo SOURCE

	# Prepare the package
	[[ ! -z "$REPOSITORY" ]] || { echo "pkgbuild error: $REPOSITORY must be set for SOURCE='$SOURCE' type."; exit -1; }
	append_pkginfo REPOSITORY

	version_to_git_rev

	case "$SOURCE" in
		git)
			# Use git clone to extract ups/pkgbuild. Store the SHA1 into $PKGINFO
			git clone -q "$REPOSITORY" tmp
			(cd tmp && git checkout -q $GITREV)

			SHA1=$(cd tmp && git rev-parse HEAD)
			append_pkginfo SHA1

			mkdir ups
			mv tmp/ups/pkgbuild ups

			rm -rf tmp
			;;
		git-archive)
			# Extract ups/pkgbuild using git-archive
			git archive --format=tar.gz --remote="$REPOSITORY" "$VERSION" ups/pkgbuild | tar xzf -
			if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
				die could not access "$REPOSITORY" via git-archive. has it been tagged with "$VERSION"?
			fi
			;;
		"local")
			# Extract the full source using git-archive, falling back to git-clone in case of failure.
			git archive --format=tar.gz --remote="$REPOSITORY" "$VERSION" 2>/dev/null | tar xzf -
			if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
				git clone -q "$REPOSITORY" .
				git checkout -q $GITREV

				SHA1=$(git rev-parse HEAD)
				append_pkginfo SHA1

				rm -rf .git
			fi
			;;
		*)
			echo "pkgbuild error: unknown source download mechanism SOURCE='$SOURCE' (known mechanisms: git, git-archive, local)."; exit -1;
	esac

	# move pkginfo file to its final location
	mkdir -p ups
	mv "$PKGINFO" ups/pkginfo
	chmod +r ups/pkginfo

	PKGINFO="ups/pkginfo"

	msg "package contents created for '$PRODUCT-$VERSION', with sources in '$SOURCE'."
}

default_fetch()
{
	# Should obtain the source and unpack it so it's the same
	# as when it was checked out from git. The source should be unpacked to
	# $pkgroot/build
	# --
	# Called by 'eups distrib install <pkgname> <version>'
	# --
	# CWD: Called from $pkgroot
	# Env: Called in environment with setup-ed dependencies, but not the package itself
	#

	die_if_empty PRODUCT
	die_if_empty VERSION

	version_to_git_rev

	case "$SOURCE" in
		git)
			# Obtain the source from a git repository
			die_if_empty REPOSITORY
			die_if_empty SHA1

			git clone -q "$REPOSITORY" tmp
			(cd tmp && git checkout -q $SHA1)

			rm -rf tmp/.git

			find tmp -depth 1 -exec mv {} . \;
			rmdir tmp
			;;
		git-archive)
			die_if_empty REPOSITORY
			die_if_empty VERSION
			git archive --format=tar.gz  --remote="$REPOSITORY" "$VERSION" | tar xzf - --exclude ups/pkgbuild --exclude ups/pkginfo
			if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
				die could not access "$REPOSITORY" via git-archive. has it been tagged with "$VERSION"?
			fi
			;;
		"local")
			;;
		*)
			die "unknown source '$SOURCE'. Malformed archive?";
			;;
	esac
}

default_prep()
{
	# Should apply any patches and prepare the code to be built using build()
	# --
	# Called by 'eups distrib install <pkgname> <version>'
	# Caller: buildbot, to prep the package for building
	# --
	# CWD: Called from $builddir
	# Env: Called in environment with setup-ed dependencies, but not the package itself
	# --
	# Typical override:
	#   apply applicable patches from $sourcedir/patches, depending
        #   on platform we're being compiled on.
        :
}

default_build()
{
	# Called to build the package.
	# --
	# Caller: 'eups distrib install <pkgname> <version>'
	# Caller: buildbot, to build the package
	# --
	# CWD: Called from $builddir
	# Env: Called in environment with setup-ed dependencies, including self

	die_if_empty PRODUCT
	die_if_empty VERSION

	#
	# Attempt to autodetect the build system
	#
	if [[ -f SConstruct ]]; then
		scons opt=3 prefix="$PREFIX" version="$VERSION"
	elif [[ -f configure ]]; then
		./configure --prefix "$PREFIX" $CONFIGURE_OPTIONS
		make_targets $MAKE_BUILD_TARGETS
	elif [[ -f Makefile ]]; then
		make_targets $MAKE_BUILD_TARGETS
	elif [[ -f setup.py ]]; then
		python setup.py build
	else
		msg "no build system detected; assuming no build needed."
	fi
}

install_ups()
{
	# Copy the contents of ups/ to $PREFIX/ups and expand the table files
	#
	# It's necessary to call this if the native install method doesn't
	# copy/expand ups/ content

	[ ! -d ups ] && die "no 'ups' directory to copy to destination (are you running from package root?)";

	mkdir -p "$PREFIX/ups"
	cp -f -a ./ups/* "$PREFIX/ups"

	# Expand the table file, if any
	if [[ -f "$PREFIX/ups/$PRODUCT.table" ]]; then
		eups expandtable -i -W '^(?!LOCAL:)' "$PREFIX/ups/$PRODUCT.table"
	else
		msg "no table file to expand (looked for '$PREFIX/ups/$PRODUCT.table')".
	fi
}

default_install()
{
	# Called to install the package, and declare it to EUPS
	# --
	# Caller: 'eups distrib install <pkgname> <version>'
	# Caller: buildbot, to build the package
	# --
	# CWD: Called from $builddir
	# Env: Called in environment with setup-ed dependencies, including self

	die_if_empty PRODUCT
	die_if_empty VERSION

	# Remove any existing directory, but be careful
	if [[ -e "$PREFIX" ]]; then
		P0=$(cd "$(eups path 0)/$(eups flavor)" && pwd)
		P1=$(cd "$PREFIX" && pwd)

		# Delete only if $PREFIX is a proper subdirectory of eups
		# install root
		if [[ "$P0" != "$P1" && "$P1" == "$P0"* ]]; then
			msg "deleting existing install in '$P1'"
			rm -rf "$P1"
		fi
	fi

	#
	# Attempt to autodetect the build system
	#
	if [[ -f SConstruct ]]; then
		scons opt=3 prefix="$PREFIX" version="$VERSION" install
	elif [[ -f Makefile ]]; then
		make_targets $MAKE_INSTALL_TARGETS
		install_ups
	elif [[ -f setup.py ]]; then
		python setup.py install $PYSETUP_INSTALL_OPTIONS
		install_ups
	else
		# just copy everything
		mkdir -p "$PREFIX"
		cp -a ./ "$PREFIX"
		msg "Copied the product into '$PREFIX'"
	fi
}

default_usage()
{
	cat <<-"EOF"
		pkgbuild -- EupsPkg builder script

		usage: pkgbuild [-ha] [-v verbosity] verb

		  verb    : one of create, fetch, prep, build, install

		  v : set verbosity level (-2 through +2, default 0)
		  a : autodetect PRODUCT and VERSION using git
		  h : show usage instructions

		If run with 'create', the script will create './ups/pkginfo'
		with package configuration, as well as prepare the package
		depending on the chosen SOURCE.

		If run with any other verb, the script will look for
		'./ups/pkginfo' to source the configuration.  This location
		can be overridden via the PKGINFO environment variable.  If
		neither is given, the script will assume the configuration
		is passed via the environment.

		If -a is given a crude auto-detection algorithm will be
		employed to deduce PRODUCT and VERSION from git. This is
		primarily for debugging, and should _never_ be used to
		install packages.

EOF
}

#
# Define default verb implementations
#
create()  { default_create "$@"; }
fetch()   { default_fetch "$@"; }
prep()    { default_prep "$@"; }
build()   { default_build "$@"; }
install() { default_install "$@"; }
usage()   { default_usage "$@"; }

##################### ---- INITIALIZATION ---- #####################

#
# Parse command line arguments
#
VERBOSE=${VERBOSE:-0}
while getopts ":v:ha" opt; do
	case $opt in
		v) VERBOSE="$OPTARG" ;;
		a) autoversion ;;
		h) usage; exit; ;;
		\?) die "Invalid option: -$OPTARG" ;;
		:) die "Option -$OPTARG requires an argument." ;;
	esac
done
shift $((OPTIND-1))

#
# Debug level 3 activates tracing
#
[[ $VERBOSE -ge 3 ]] && set -x

[[ $# -ge 1 ]] || { error "insufficient number of arguments [$0 "$@"]."; usage; exit -1; }

#
# Source the pkginfo file
#

if [[ "$1" != "create" ]]; then
	if [[ ! -z "$PKGINFO" ]]; then
		. "$PKGINFO"
	elif [[ -f ups/pkginfo ]]; then
		PKGINFO=ups/pkginfo
		. "$PKGINFO"
	elif [[ -z "$PRODUCT" || -z "$VERSION" ]]; then
		warn "no './ups/pkginfo' file, and PKGINFO, PRODUCT nor VERSION are defined. hope you know what you're doing."
	fi
fi

#
# UNDOCUMENTED FEATURE: eval command line overrides (typically variable
# definitions; VAR1=A VAR2=B ...)
#
eval "${@:2}"

#
# Try to figure out how many cores does this machine have, and tweak
# MAKEFLAGS and SCONSFLAGS accordingly
#
use_parallel_jobs $((sysctl -n hw.ncpu || (test -r /proc/cpuinfo && grep processor /proc/cpuinfo | wc -l) || echo 2) 2>/dev/null)

#
# Defaults the user can further override in pkgbuild
#
SOURCE=${SOURCE:-local}					# [local|git|git-archive]. Usually passed in via command line (eups distrib create ... -S SOURCE=...)
REPOSITORY=${REPOSITORY:-}				# URL to git repository
MAKE_BUILD_TARGETS=${MAKE_BUILD_TARGETS:-}		# Targets for invocation of make in build phase
MAKE_INSTALL_TARGETS=${MAKE_INSTALL_TARGETS:-"install"}	# Targets for invocation of make in test phase
CONFIGURE_OPTIONS=${CONFIGURE_OPTIONS:-}		# Options passed to ./configure. Note that --prefix is passed separately.

PREFIX=${PREFIX:-"$(eups path 0)/$(eups flavor)/$PRODUCT/$VERSION"}

PYSETUP_INSTALL_OPTIONS=${PYSETUP_INSTALL_OPTIONS:-"--prefix $PREFIX"}	# Options passed to setup.py install. Note that --prefix is NOT passed separately!
